1)  I saw that right before calling strings not equal, the program moved whatever was at address 0x4023b0 into register %esi. So I used the command "x/s 0x4023b0" and it produced the string "And they have no disregard for human life.". It seemed obvious that this was the correct string to use so I tried it as input and it worked!

2)  I saw that there was a call to "read_six_numbers" which I figured out was checking to see if your input was six numbers separated by spaces. Next I saw the comparison of "$0x1 to (%rsp)" which I figured out was telling me that the first number in my sequence was a 1. Then I saw a loop from lines 33-54 which had a comparison of "%eax to 0x4(%rbx)" which I figured out was checking our sequence against the correct number. I then formulated my answer by stepping through the loop and getting one number at a time till I saw the pattern of 2^0, 2^1,...

3)  First I saw that after the call to scanf, the function compared "%eax to 0x2" and then had a jump greater than instruction next to move past the call to explode bomb. I took this as you need to have 3 inputs separated by spaces. Next, on line 136, I saw "cmp $0x2ef, 0x8(%rsp)" and then a jump statement to the last compare statement and explode_bomb call. I used ""x/16wd $rsp" to print out the next 16 32-bit decimal numbers from rsp. I saw that at %rsp + 0x8 was my second input and at %rsp + 0xc was my first input. So, this line was checking to see if my input was the same as 0x2ef (751), leading me to the conclusion that my second inout had to be 751. Next, the program jumped down to a comparison between "cmp 0x7($rsp), $al". Here, $al contained the value 101 and $rsp + 0x7 contained my character and its ascii value. I realized that I needed the character with the ascii value 101, which is 'e', so I tried it as input and it worked. I don't really understand why 2 worked as my first input. I first tried it because I saw a compariosn between 0x2 and $rax and just tried 2. Later I realized that the comparison was actually checking for the number of inputs I had. 

4)  First, I saw that after the call to scanf, there was "cmp $0x2, %eax" then a "jne" to a call to explode_bomb. I took this as I needed two inputs separated by a space. Next, I saw that the program moved my second input into %eax right before there was a "cmp $0x2, %eax" then a "jbe" past a call to explode_bomb. I realized that whatever my second input was had to be less than or equal to 2 after having 2 subtracted from it. So i tailored my second input to fit the condition. Next, I saw that the program compared whatever my first input was to whatever was stored in %rsp+8 ("cmp 0x8(%sp), %eax"). I checked what was stored in %rsp+8, 352, and then tailored my input to fit the criteria. 

5)  First, I saw that right after the call to string_length, there was a "cmp %0x6, %eax" and then a "je" past a call to explode_bomb. I took this as I needed a string of length 6. I first tried "abcdef". When I got to line 53 where "cmp $0x2d, %ecx" was something against the value 45. I realized that there was a loop that was summing up some value assigned to each character in the string, and then comparing it to 45. I then saw that line 37 was adding something from location 0x402460 + some stuff. So I used "x/16wd $0x402460" to print out the next 16 word-sized decial numbers from that position. I realized that this was an array that was assigning values to certain ascii characters, then adding that value to a total sum for the string. I tried to decipher what the ecnoding was for each character, but couldn't seem to figure it out. So, I decided to create a map or characters, starting with "abcdef" then "ghijkl" until I had enough values to add up to 45 while only using 6 characters. I created my string from those characters and it worked.

6)  First, I saw there was a call to read_six_numbers. So I tailored my input to 1 2 3 4 5 6. After some manipulation, I finially got to line 202 where I had a "cmp %eax, (%rbx)". Using commands like x/d $rbx, I found out that I was dealing with a linked list. I used the command "x/24wd $rbx" to print the list of nodes in the linked list. It showed me the values at each node, and the numbers associated with those values. I figured out that I needed to order the nodes from least to greatest based off line 204 "jle 0x401172 <phase_6+211>". I then ordered my input based off the value assigned to each number, 1 2 3 4 5 6, and the value assigned to them in the linked list, 68, 202, 270, 416, 464, 501. This produced the correct result.